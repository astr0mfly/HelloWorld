<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on Valencia</title>
    <link>https://astr0mfly.github.io/blog/</link>
    <description>Recent content in Blog on Valencia</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Thu, 13 Sep 2018 22:31:21 +0800</lastBuildDate>
    
	<atom:link href="https://astr0mfly.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Server-Interview</title>
      <link>https://astr0mfly.github.io/blog/2019-04/server-interview/</link>
      <pubDate>Mon, 29 Apr 2019 06:19:10 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/server-interview/</guid>
      <description>面试经验总结 编程语法相关 计算机网络 Q：epoll/select 模型的底层实现 区别 epoll的lt和et模式及对缓冲区的理解 错误处理 &amp;gt;1 Q：网络字节序 大小端 &amp;gt;A：ntohl ntohs htonl htons 可以用这四个函数进行字节序转换,网络字节序 为大端 主机字节序为小端(一般) Q:进程池与线程池 实现一个线程池（写代码） &amp;gt;用posix条件变量和信号量实现 Q:生产者消费者模型问题 实现一个什么问题记不清了 涉及了pv操作 同步</description>
    </item>
    
    <item>
      <title>Tcp-Reaction</title>
      <link>https://astr0mfly.github.io/blog/2019-04/tcp-reaction/</link>
      <pubDate>Mon, 29 Apr 2019 02:47:43 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/tcp-reaction/</guid>
      <description>TCP通信基本流程 Windows 和 Linux 上常用的 socket API 函数并不多，除了特定操作系统提供的一些基于自身系统特性的 API， 大多数 Socket API 都源于BSD Socket （即伯克利套接字（Berkeley Sockets）），因此这些 socket 函数在不同的平台有着相似的签名和参数。 linux 查看socket函数帮助 man bind、man man、man 3 sleep windows 查看帮助 使用在线版本的 MSDN 理论剖析 服务端流程 &amp;gt;1. 调用 socket 函数创建 socket（侦听socket） &amp;gt;2. 调用 bind 函数 将 soc</description>
    </item>
    
    <item>
      <title>Mysql-Index</title>
      <link>https://astr0mfly.github.io/blog/2019-04/mysql-index/</link>
      <pubDate>Thu, 25 Apr 2019 09:49:26 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/mysql-index/</guid>
      <description>索引的本质 MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree</description>
    </item>
    
    <item>
      <title>Distri-Consisitency</title>
      <link>https://astr0mfly.github.io/blog/2019-04/distri-consisitency/</link>
      <pubDate>Thu, 25 Apr 2019 08:51:17 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/distri-consisitency/</guid>
      <description>分布式系统中一个重要的问题就是数据复制，数据复制一般是为了增强系统的可用性或提高性能。而实现数据复制的一个主要难题就是保持各个副本的一致性。 什么是一致性模型 一致性模型本质上是进程与数据存储的约定：如果进程遵循某些规则，那么进程对数据的读写操作都是可预期的。 一致性模型主要可以分为两类：能够保证所有进程对数据的读写顺序都保持一致的一致性模型称为强一致性模型，而不能保证的一致性模型称为弱一致性模型。 强一</description>
    </item>
    
    <item>
      <title>Distri-Queue</title>
      <link>https://astr0mfly.github.io/blog/2019-04/distri-queue/</link>
      <pubDate>Thu, 25 Apr 2019 08:17:54 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/distri-queue/</guid>
      <description>摘要 作为一种基础的抽象数据结构，队列被广泛应用在各类编程中。 - 使用分布式队列的时候，没有意识到它是队列。 - 有具体需求的时候，忘记了分布式队列的存在。 方案选型 当确定系统之间有通信需求的时候，工程师们需要做很多的决策和平衡，这直接影响工程师们是否会选择分布式队列编程模型作为架构。从这个角度出发，影响建模的因素有四个：When、Who、Where、How。 when：同步VS异步 基本问题：发出去的消息什么</description>
    </item>
    
    <item>
      <title>distri-load_balance</title>
      <link>https://astr0mfly.github.io/blog/2019-04/distri-load_balance/</link>
      <pubDate>Thu, 25 Apr 2019 07:04:20 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/distri-load_balance/</guid>
      <description>负载均衡(Load Balance) 负载均衡可以将工作任务分摊到多个处理单元，从而提高并发处理能力。 常见的web负载均衡技术包括：DNS轮询、IP负载均衡和CDN。其中IP负载均衡可以使用硬件设备或软件方式来实现。 服务器集群(Cluster)使得多个服务器节点能够协同工作，根据目的的不同，服务器集群可以分为： 高性能集群：将单个重负载的请求分散到多个节点进行处理，最后再将处理结果进行汇总 高可用集群：提高冗余单元，避</description>
    </item>
    
    <item>
      <title>Shell-AutoCookies</title>
      <link>https://astr0mfly.github.io/blog/2019-04/shell-autocookies/</link>
      <pubDate>Thu, 25 Apr 2019 04:26:27 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/shell-autocookies/</guid>
      <description>用awk过滤docker容器ip #!/bin/bash #docker ps |awk &#39;{if($2==&amp;quot;hyperledger/fabric-kafka&amp;quot;) print $1}&#39; #docker ps |awk &#39;{if($2==&amp;quot;hyperledger/fabric-kafka&amp;quot;){ print $1;cmd=&amp;quot;docker exec &amp;quot;$1&amp;quot; ifconfig&amp;quot;;system(cmd);}}&#39;|grep addr:|awk &#39;{print $2}&#39;|awk -F &amp;quot;:&amp;quot; &#39;{print $2}&#39; #docker ps |awk &#39;{if($2==&amp;quot;hyperledger/fabric-kafka&amp;quot;){ print $1;cmd=&amp;quot;docker exec &amp;quot;$1&amp;quot; ifconfig&amp;quot;;system(cmd);}}&#39;|grep addr:|awk &#39;{print $2}&#39;|awk -F &#39;[ :]&#39; &#39;{print $2}&#39; docker ps |awk &#39;{if($2==&amp;quot;hyperledger/fabric-kafka&amp;quot;){ print $1;cmd=&amp;quot;docker exec &amp;quot;$1&amp;quot; ifconfig&amp;quot;;system(cmd);}}&#39;|awk &#39;{if($2 ~/addr:*/ &amp;amp;&amp;amp; $2!~/addr:127.0.0.1/){print $2}}&#39;|awk -F &#39;[ :]&#39; &#39;{print $2}&#39; out root@liu:~/work/go/src/github.com/hyperledger/fabric/examples/e2e_cli# ./catip.sh 172.18.0.8 172.18.0.7 172.18.0.6 172.18.0.5 root@liu:~/work/go/src/github.com/hyperledger/fabric/examples/e2e_cli# 版本控制 Version Action Time 1.0 Init 2019-04-25T04:26:27-07:00</description>
    </item>
    
    <item>
      <title>Go-Lession</title>
      <link>https://astr0mfly.github.io/blog/2019-04/go-lession/</link>
      <pubDate>Thu, 25 Apr 2019 04:21:58 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/go-lession/</guid>
      <description>启动两个线程，合并输出 package main import &amp;quot;fmt&amp;quot; func main() { ch1 := make(chan int) ch2 := make(chan int) go func() { for i := 0; i &amp;lt; 10; i++ { if i%2 == 0 { ch1 &amp;lt;- i } } }() go func() { for i := 0; i &amp;lt; 10; i++ { if i%2 == 1 { ch2 &amp;lt;- i } } }() tmp := 0 for i := 0; i &amp;lt; 5; i++ { tmp = &amp;lt;-ch1 fmt.Println(tmp) tmp = &amp;lt;-ch2 fmt.Println(tmp) } } for-range package main import &amp;quot;fmt&amp;quot; func main() { slice := []int{0, 1, 2, 3} mp := make(map[int]*int) fmt.Println(&amp;quot;for range 坑&amp;quot;) for index, value := range slice { mp[index] = &amp;amp;value } //根本原因在于for range是用一个变量承接mp中的内容的 for key, value := range mp { fmt.Println(key, &amp;quot; &amp;quot;, *value) } fmt.Println(&amp;quot;等价写法&amp;qu</description>
    </item>
    
    <item>
      <title>distributed-mapreduce</title>
      <link>https://astr0mfly.github.io/blog/2019-04/distributed-mapreduce/</link>
      <pubDate>Thu, 25 Apr 2019 03:51:49 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/distributed-mapreduce/</guid>
      <description>MapReduce(并行运算编程模型)基础概念 MapReduce是一种编程模型，用于大规模数据集（大于1TB）的并行运算。概念&amp;rdquo;Map（映射）&amp;rdquo;和&amp;rdquo;Reduce（归约）&amp;rdquo;，是它们的主要思想.软件实现是指定一个Map（映射）函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归约）函数，用来保证所有映射的键值对中的每一个共享相同的键组。</description>
    </item>
    
    <item>
      <title>C&#43;&#43;如何做到反射</title>
      <link>https://astr0mfly.github.io/blog/2019-04/c-%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Thu, 25 Apr 2019 03:10:41 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/c-%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%8F%8D%E5%B0%84/</guid>
      <description>什么是反射 反射机制在java中是一个非常重要的特性，比如在spring框架中，就使用了xml + 反射来完成类的动态扩展。 换句话说，反射就是根据一个字符串查找到一个类，查找到一个函数，并能生成这个类，或者函数的实例；就是在运行期通过字符串到内存单元的反向映射。 怎么做到反射 在动态语言中，反射是非常容易实现的，在java中，由于有字节码作为中间层的存在，所以实现也并不复杂。但是对于c++来说，静态编译的程</description>
    </item>
    
    <item>
      <title>git-flow</title>
      <link>https://astr0mfly.github.io/blog/2019-04/git-flow/</link>
      <pubDate>Wed, 24 Apr 2019 20:24:45 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/git-flow/</guid>
      <description>Devops = &amp;ldquo;Development&amp;rdquo; + &amp;ldquo;Operations&amp;rdquo; DevOps 是一个完整的面向IT运维的工作流，以 IT 自动化以及持续集成（CI）、持续部署（CD）为基础，来优化程式开发、测试、系统运维等所有环节。 在敏捷开发的基础上，提出开发与运营之间的软件版本迭代循环。 工具链 代码管理（SCM）：GitHub、GitLab、BitBucket、SubVersion 构建工具：Ant、Gradle、maven 自动部署：Capistrano、CodeDeploy 持续集成（</description>
    </item>
    
    <item>
      <title>基于GO的分布式云存储框架</title>
      <link>https://astr0mfly.github.io/blog/2019-04/%E5%9F%BA%E4%BA%8Ego%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%91%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Wed, 24 Apr 2019 20:21:23 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/%E5%9F%BA%E4%BA%8Ego%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%91%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6/</guid>
      <description>AstroCloudFIle 基于golang实现的一种分布式云存储服务 关于分支和标签 分支说明: master分支: 通过原生net/http实现各接口功能 gin分支: 通过Gin框架来改造(微服务化章节之后主要基于Gin框架来进行演示) pkg分支: 通过go-bindata等工具实现静态资源打包的一个示例 标签 tag是分支代码某个阶段的快照。如master主分支的v0.1是首个发布的版本，该版本是接入了阿里OSS。 关于需要手动安装的</description>
    </item>
    
    <item>
      <title>设计模式</title>
      <link>https://astr0mfly.github.io/blog/2019-04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 24 Apr 2019 08:14:44 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>简介 推荐书籍《设计模式&amp;ndash;可复用面向对象软件的基础》 底层思维：向下，把握机器底层-&amp;gt;语言构造、编译转换、内存模型、运行机制 抽象思维：面向对象、组件封装、设计模式、架构模式 深入理解三大面向对象机制： - 封装，隐藏内部实现 - 继承，复用现有代码 - 多态，改写对象行为 设计模式详解 策略模式 起因 软件构造的过程中，算法和对象容易耦合，那么能不能让算法与对象本身解耦呢？ 要点 Strategy及其字类为组</description>
    </item>
    
    <item>
      <title>Go-国内下载官方工具</title>
      <link>https://astr0mfly.github.io/blog/2019-04/go-%E5%9B%BD%E5%86%85%E4%B8%8B%E8%BD%BD%E5%AE%98%E6%96%B9%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 24 Apr 2019 06:45:07 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/go-%E5%9B%BD%E5%86%85%E4%B8%8B%E8%BD%BD%E5%AE%98%E6%96%B9%E5%B7%A5%E5%85%B7/</guid>
      <description>国内下载golang.org中的工具包 国内有某种不可描述的原因，导致无法访问 golang.org,但是使用golang时官方工具包是必不可少的一部分. golang.org/x/这个目录，其实镜像托管在 github.com/golang/ GIT迁移 将Github的包下载到本地后，移动到相应的目录中. 如: net &amp;ndash;&amp;gt;&amp;gt; GOPATH/src/golang.org/x/net crypto &amp;ndash;&amp;gt;&amp;gt; GOPATH/src/golang.org/x/crypto build &amp;ndash;&amp;gt;&amp;gt; GOPATH/src/golang.org/x/build &amp;hellip; GIT下载 在 $GOPATH/src/golang.org/x/ 下通过git 进行 clone 如: ~/go/src/golang.org/x$ git clone http://github.com/golang/build 然后用git pull直接维护更新本地代码 版本控制 Version Action Time 1.0 Init 2019-04-24T06:45:07-07:00</description>
    </item>
    
    <item>
      <title>Golang安装环境搭建</title>
      <link>https://astr0mfly.github.io/blog/2019-04/golang%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Mon, 22 Apr 2019 04:12:48 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/golang%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>Go安装包下载 由于Go的官方网址国内不可达，推荐一个国内的镜像源： go语言中文网.Go安装包下载 编译安装 下载Linux版本：go1.12.4.linux-amd64.tar.gz #在下载文件夹下的Shell敲一下如下命令 sudo tar -C /usr/local -xzvf go1.12.4.linux-amd64.tar.gz #/etc/profile（全系统安装）或 $HOME/.profile 添加环境变量 export PATH=$PATH:/usr/local/go/bin 也有另一种方法添加环境变量： # vim /etc/profile.d/go.sh export PATH=$PATH:/usr/local/go/bin export GOPATH=$HOME/dev/go export GOBIN=$GOPATH/bin :wq! # source /etc/profile.d/go.sh 验证结果 创建一个hello.go的文件 package main import &amp;quot;fmt&amp;quot; func main() { fmt.Printf(&amp;quot;hello,</description>
    </item>
    
    <item>
      <title>使用hugo制作静态个人界面</title>
      <link>https://astr0mfly.github.io/blog/2019-04/%E4%BD%BF%E7%94%A8hugo%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%95%8C%E9%9D%A2/</link>
      <pubDate>Mon, 22 Apr 2019 04:09:23 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/%E4%BD%BF%E7%94%A8hugo%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%95%8C%E9%9D%A2/</guid>
      <description>安装hugo 建议到如下链接下载对应文件，使用go get挺慢的。 https://github.com/gohugoio/hugo/releases 安装hugo 生成site并且 clone 对应皮肤的Git到theme文件夹下 调试 ：hugo server --theme=hyde --buildDrafts 打开 : http://localhost:1313 实时调试 生成部署： hugo --theme=hyde 上传到git ： git push -u origin master 实例皮肤：redlougue hugo链接： https://github.com/tmaiaroto/hugo-redlounge 路径解释 config.toml 站点全局的参数配置文件 archetypes Hugo的markdown文件中前置数据Front Matter定义的结构，默认使用的是default.md文件，可以自</description>
    </item>
    
    <item>
      <title></title>
      <link>https://astr0mfly.github.io/blog/1-01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/1-01/</guid>
      <description>  series: []  .task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }   body { font-family: -apple-system, BlinkMacSystemFont, &#39;Segoe WPC&#39;, &#39;Segoe UI&#39;, &#39;Ubuntu&#39;, &#39;Droid Sans&#39;, sans-serif; font-size: 14px; line-height: 1.6; }      date: &amp;quot;2019-04-29T06:42:08-07:00&amp;quot; draft: true title: &amp;quot;Distri-Design&amp;quot; tags: [Distributed] #series: [] categories: [] toc: true 分布式系统设计 分布式系统设计主要有关于四个重点两个小点。
四个重点 容错能力（服务隔离、异步调用、请求幂等性、分布式锁） 何为容错能力： 系统在不健康、不顺，甚至出错的情况下有能力 hold 得住，挺得住，还有能在这种逆境下力挽狂澜的能力；我们都知道，故障是必然会发生的，是正常的，是常见的，我们应该把处理故障的代码当成正常的功能做在架构里写在代码里。
请求幂等：幂等并不是每次请求的结果都一样，而是一次和多次请求某一个资源应该具有同样的副作用，f(x) = f(f(x))，要做到幂等性的交易接口，需要有一个唯一的标识，来标志交易是同一笔交易，这个标识要能做到全局唯一。幂等还是比较容易实现的，比如对于转账交易（支付系统一定要保证幂等），最简单的就是每次请求都带有一个唯一标识id，比如一个请求（id,money），此id标识在数据库中能唯一确定一条记录；若因为网络故障客户端多次请求同一个转账交易（id,money），服务端必须保证只能有一次记录成功，对于其他重复请求应该给客户端明确的解析语义。我们一般保证幂等的判断是从数据库查询有没有相同id的记录，但是在分布式系统环境下，可能有问题，主从问题：两个相同的请求request1、request2时间间隔很短，request1请求过来的时候，查询从库发现没有对应记录，则request1开始操作插入主库record1，但是还没有同步到从库；此时request2查询从库（主从还未同步）也发现没有相同id的记录，准备插入有相同id的记录record2，这个时候request1成功插入record1，request2开始插入record2，数据库报错：唯一约束被破坏相关的异常日志；解决这个问题有两种方法：1、读写都强制走主库；2、采用分布式锁，考虑性能问题，一般都选2 分布式锁：分布式系统一般都有多台机器，常规的多线程锁已经无法解决问题；最简单用redis实现：思路很简单，主要用到的redis函数是setnx()。首先是将某一任务标识名UniqueKey（能唯一识别一个请求的标识）作为键存到redis里，并为其设个过期时间，如果是同样的请求过来，先是通过setnx()看看是否能将UniqueKey插入到redis里，可以的话就返回true，不可以就返回false。
 分布式锁设计原则： 互斥性，同一时间只有一个线程持有锁 容错性，即使某一个持有锁的线程，异常退出，其他线程仍可获得锁 隔离性，线程只能解自己的锁，不能解其他线程的锁
 服务隔离：是为了在系统发生故障时能限定传播范围和影响范围，即发生故障后不会出现滚雪球效应，从而保证只有出问题的服务不可用，其他服务还是可用的。
异步调用：发送方发送请求后，接收方直接返回正在处理，通过轮询或者回调的方式返回结果；异步调用相比于同步调用的最大好处是可以快速相应客户端的请求，至于具体的请求结果，通过异步回调的方式发送给客户端，这种方式在服务端平均处理请求时间过长的业务场景下很好用，避免在高请求流量下的超时、阻塞等问题；
可伸缩性（有 / 无状态的服务） 无状态服务在程序 Bug 上和水平扩展上有非常优秀的表现，但是在一致性上却有劣势，事物总是相对的（个人此点能力不足，不足以论述）
可伸缩性（有 / 无状态的服务） ACID :大家在买同一本书的过程中，每个用户的购买请求都需要把库存锁住，等减完库存后，把锁释放出来，后续的人才能进行购买。同一时间不可能有多个用户下单，订单流程需要有排队的情况，这样一来，我们就不可能做出性能比较高的系统来。
BASE :大家都可以同时下单，这个时候不需要去真正地分配库存，然后系统异步地处理订单，而且是批量的处理。因为下单的时候没有真正去扣减库存，所以，有可能会有超卖的情况。而后台的系统会异步地处理订单时，发现库存没有了，于是才会告诉用户你没有购买成功。
强一致性（ACID）和高可用性（BASE）是对立，顾此失彼；因此，为了可用性，我们要讲业务中需要强一致性的动作和不需要强一致性的动作剥离开，对于非强一致性需求的动作，可以做补偿事务；我们应尽量设计更多非强一致性的业务 由于网络等问题，一些请求无法确定是否成功，这个时候需要重试，即在此发送请求给服务端，希望服务端能确定的交易结果，重试一般通过定时任务扫表，将不是终态的记录查询出在此发请求。
应对大流量的能力（熔断、降级） 熔断（慎用）：如果系统中，某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用；熔断主要是应对流量引起的问题，弃卒保车，使服务处于关闭、半关闭状态，以保证部分业务成功，或者舍弃次要业务使主业务运行通畅；
限流：熔断的一种，半开状态，只允许少部分的请求，其他的都拒绝，如果设计得当，被拒绝的请求，客户端会通过重试、补偿操作来完成；
降级：暂时牺牲掉一些服务，保障整个系统的服务。比如：如果服务器已经高负载，这个时候可以将一些不重要的操作给关闭，比如重试操作，因为服务器已经承受不住，这个时候再重试也没有多大效果，反而更加重服务端的压力，这个时候可以设置一个开关，将重试功能关闭；
两个小点 解耦（MQ） 在软件工程中，对象之间的耦合度就是对象之间的依赖性。对象之间的耦合越高，维护成本越高，因此对象的设计应使模块之间的耦合度尽量小。在软件架构设计中，模块之间的解耦或者说松耦合有两种，假设有两个模块A、B，A依赖B：
第一种是，模块A和模块B只通过接口交互，只要接口设计不变，那么模块B内部细节的变化不影响模块A对模块B服务能力的消费。 面向接口设计下真正实现了将接口契约的定义和接口的实现彻底分离，实现变化不影响到接口契约，自然不影响到基于接口的交互。 模块A和B之间的松耦合，主要通过合理的模块划分、接口设计来完成。如果出现循环依赖，可以将模块A、B共同依赖的部分移除到另一个模块C中，将A、B之间的相互依赖，转换为A、B同时对C的依赖。
第二种是，将同步调用转换成异步消息交互。 比如在买机票系统中，机票支付完成后需要通知出票系统出票、代金券系统发券。如果使用同步调用，那么出票系统、代金券系统宕机是会影响到机票支付系统，如果另一个系统比如专车系统也想要在机票支付完成后向用户推荐专车服务，那么同步调用模式下机票支付系统就需要为此而改动，容易影响核心支付业务的可靠性。 如果我们将同步调用替换成异步消息，机票支付系统发送机票支付成功的消息到消息中间件，出票系统、代金券系统从消息中间件订阅消息。这样一来，出票系统、代金券系统的宕机也就不会对机票支付系统造成任何影响了。专车系统想要知道机票支付完成这一事件，也只需要从消息中间件订阅消息即可，机票支付系统完全不需要做任何改动。 异步消息解耦，适合那些信息流单向流动（类似发布-订阅这样的），实时性要求不高的系统。常见的开源消息队列框架有：Kafka、RabbitMQ、RocketMQ。
线程池 线程池：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间，且创建过多的线程会耗费系统资源，频繁的上下文切换也影响系统的性能。
实战分析 分析项目一：三个系统，A、B、C；A负责下单菜品:aaa，B负责接受A的下单请求，比根据A传递过来的aaa查询C得到菜品的详情，然后在继续下单；我们可以看出如果C系统挂了，整个下单流程就挂了，无法下单了；如何降级？B将C的菜品数据也存一份，正常情况下用C的菜品查询（C的菜品数据实时性更好一点），如果C挂了，B就用自己存的菜品，作为一种临时方案，达到可继续下单的目的，毕竟不能因为一个查询系统挂了导致整个下单功能不能用，这就是一种降级处理～
分析项目二：关闭重试机制；很多项目都有超时重试的机制，这种机制在服务已经负载过大、无法及时处理时，应当将重试逻辑关闭，避免因重试导致更严重的服务负担。
分析项目三：控制入口访问权限，白名单可用，当服务负载过大，可以通过在入口(比如拦截器中进行控制)控制流量，比如只允许vip客户访问，通过添加白名单方式来实现。
 高可用设计注意事项 分析项目一：缓存，不要放在业务侧，要在数据源头设置，业务方只负责增删改；否则可能造成多个业务方的数据不一致；
版本控制    Version Action Time     1.0 Init 2019-04-29T06:42:08-07:00     </description>
    </item>
    
    <item>
      <title></title>
      <link>https://astr0mfly.github.io/blog/1-01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/1-01/</guid>
      <description>series: []  .task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }   body { font-family: -apple-system, BlinkMacSystemFont, &#39;Segoe WPC&#39;, &#39;Segoe UI&#39;, &#39;Ubuntu&#39;, &#39;Droid Sans&#39;, sans-serif; font-size: 14px; line-height: 1.6; }      date: &amp;quot;2019-04-29T02:47:43-07:00&amp;quot; draft: false title: &amp;quot;Tcp-Reaction&amp;quot; tags: [cpp] #series: [] categories: [编码之道] toc: true TCP通信基本流程 Windows 和 Linux 上常用的 socket API 函数并不多，除了特定操作系统提供的一些基于自身系统特性的 API， 大多数 Socket API 都源于BSD Socket （即伯克利套接字（Berkeley Sockets）），因此这些 socket 函数在不同的平台有着相似的签名和参数。
 linux 查看socket函数帮助  man bind、man man、man 3 sleep   windows 查看帮助  使用在线版本的 MSDN    理论剖析  服务端流程    调用 socket 函数创建 socket（侦听socket） 调用 bind 函数 将 socket绑定到某个ip和端口的二元组上 调用 listen 函数 开启侦听 当有客户端请求连接上来后，调用 accept 函数接受连接，产生一个新的 socket（客户端 socket） 基于新产生的 socket 调用 send 或 recv 函数开始与客户端进行数据交流 通信结束后，调用 close 函数关闭侦听 socket    客户端流程    调用 socket函数创建客户端 socket 调用 connect 函数尝试连接服务器 连接成功以后调用 send 或 recv 函数开始与服务器进行数据交流 通信结束后，调用 close 函数关闭侦听socket   上述流程交互总结如下： 代码实现 Server
#include &amp;lt;sys/types.h&amp;gt;  #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;arpa/inet.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;string.h&amp;gt; int main(int argc, char* argv[]) { //1.创建一个侦听socket int listenfd = socket(AF_INET, SOCK_STREAM, 0); if (listenfd == -1) { std::cout &amp;lt;&amp;lt; &#34;create listen socket error.&#34; &amp;lt;&amp;lt; std::endl; return -1; } //2.初始化服务器地址 struct sockaddr_in bindaddr; bindaddr.</description>
    </item>
    
  </channel>
</rss>