<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Valencia</title>
    <link>https://astr0mfly.github.io/</link>
    <description>Recent content on Valencia</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Mon, 29 Apr 2019 02:47:43 -0700</lastBuildDate>
    
	<atom:link href="https://astr0mfly.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Tcp-Reaction</title>
      <link>https://astr0mfly.github.io/blog/2019-04/tcp-reaction/</link>
      <pubDate>Mon, 29 Apr 2019 02:47:43 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/tcp-reaction/</guid>
      <description>TCP通信基本流程 Windows 和 Linux 上常用的 socket API 函数并不多，除了特定操作系统提供的一些基于自身系统特性的 API， 大多数 Socket API 都源于BSD Socket （即伯克利套接字（Berkeley Sockets）），因此这些 socket 函数在不同的平台有着相似的签名和参数。 linux 查看socket函数帮助 man bind、man man、man 3 sleep windows 查看帮助 使用在线版本的 MSDN 理论剖析 服务端流程 &amp;gt;1. 调用 socket 函数创建 socket（侦听socket） &amp;gt;2. 调用 bind 函数 将 soc</description>
    </item>
    
    <item>
      <title>Life-Fast_employee</title>
      <link>https://astr0mfly.github.io/moment/life-fast_employee/</link>
      <pubDate>Thu, 25 Apr 2019 10:49:04 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/moment/life-fast_employee/</guid>
      <description>前言 找到满意的工作比想像中难多了，不仅仅是因为时间不对，其实还有自身的技能匹配问题。 - 有计划——计划好每天要复习的知识模块（内容较多） - 高效率——从整体到细节，着重把知识点“手写”到自己的电脑记录本 - 优简历——展示你的项目亮点，难点 有计划 反思： 为什么好多知识看过后不能记住，面试一紧张更加想不起？一方面自己没有深入学习，另一方面复习过程杂乱，和写代码一个道理，如果你的业务逻辑和其他乱七八糟的都放在控</description>
    </item>
    
    <item>
      <title>Mysql-Index</title>
      <link>https://astr0mfly.github.io/blog/2019-04/mysql-index/</link>
      <pubDate>Thu, 25 Apr 2019 09:49:26 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/mysql-index/</guid>
      <description>索引的本质 MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree</description>
    </item>
    
    <item>
      <title>Distri-Consisitency</title>
      <link>https://astr0mfly.github.io/blog/2019-04/distri-consisitency/</link>
      <pubDate>Thu, 25 Apr 2019 08:51:17 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/distri-consisitency/</guid>
      <description>分布式系统中一个重要的问题就是数据复制，数据复制一般是为了增强系统的可用性或提高性能。而实现数据复制的一个主要难题就是保持各个副本的一致性。 什么是一致性模型 一致性模型本质上是进程与数据存储的约定：如果进程遵循某些规则，那么进程对数据的读写操作都是可预期的。 一致性模型主要可以分为两类：能够保证所有进程对数据的读写顺序都保持一致的一致性模型称为强一致性模型，而不能保证的一致性模型称为弱一致性模型。 强一</description>
    </item>
    
    <item>
      <title>Distri-Queue</title>
      <link>https://astr0mfly.github.io/blog/2019-04/distri-queue/</link>
      <pubDate>Thu, 25 Apr 2019 08:17:54 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/distri-queue/</guid>
      <description>摘要 作为一种基础的抽象数据结构，队列被广泛应用在各类编程中。 - 使用分布式队列的时候，没有意识到它是队列。 - 有具体需求的时候，忘记了分布式队列的存在。 方案选型 当确定系统之间有通信需求的时候，工程师们需要做很多的决策和平衡，这直接影响工程师们是否会选择分布式队列编程模型作为架构。从这个角度出发，影响建模的因素有四个：When、Who、Where、How。 when：同步VS异步 基本问题：发出去的消息什么</description>
    </item>
    
    <item>
      <title>distri-load_balance</title>
      <link>https://astr0mfly.github.io/blog/2019-04/distri-load_balance/</link>
      <pubDate>Thu, 25 Apr 2019 07:04:20 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/distri-load_balance/</guid>
      <description>负载均衡(Load Balance) 负载均衡可以将工作任务分摊到多个处理单元，从而提高并发处理能力。 常见的web负载均衡技术包括：DNS轮询、IP负载均衡和CDN。其中IP负载均衡可以使用硬件设备或软件方式来实现。 服务器集群(Cluster)使得多个服务器节点能够协同工作，根据目的的不同，服务器集群可以分为： 高性能集群：将单个重负载的请求分散到多个节点进行处理，最后再将处理结果进行汇总 高可用集群：提高冗余单元，避</description>
    </item>
    
    <item>
      <title>Shell-AutoCookies</title>
      <link>https://astr0mfly.github.io/blog/2019-04/shell-autocookies/</link>
      <pubDate>Thu, 25 Apr 2019 04:26:27 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/shell-autocookies/</guid>
      <description>用awk过滤docker容器ip #!/bin/bash #docker ps |awk &#39;{if($2==&amp;quot;hyperledger/fabric-kafka&amp;quot;) print $1}&#39; #docker ps |awk &#39;{if($2==&amp;quot;hyperledger/fabric-kafka&amp;quot;){ print $1;cmd=&amp;quot;docker exec &amp;quot;$1&amp;quot; ifconfig&amp;quot;;system(cmd);}}&#39;|grep addr:|awk &#39;{print $2}&#39;|awk -F &amp;quot;:&amp;quot; &#39;{print $2}&#39; #docker ps |awk &#39;{if($2==&amp;quot;hyperledger/fabric-kafka&amp;quot;){ print $1;cmd=&amp;quot;docker exec &amp;quot;$1&amp;quot; ifconfig&amp;quot;;system(cmd);}}&#39;|grep addr:|awk &#39;{print $2}&#39;|awk -F &#39;[ :]&#39; &#39;{print $2}&#39; docker ps |awk &#39;{if($2==&amp;quot;hyperledger/fabric-kafka&amp;quot;){ print $1;cmd=&amp;quot;docker exec &amp;quot;$1&amp;quot; ifconfig&amp;quot;;system(cmd);}}&#39;|awk &#39;{if($2 ~/addr:*/ &amp;amp;&amp;amp; $2!~/addr:127.0.0.1/){print $2}}&#39;|awk -F &#39;[ :]&#39; &#39;{print $2}&#39; out root@liu:~/work/go/src/github.com/hyperledger/fabric/examples/e2e_cli# ./catip.sh 172.18.0.8 172.18.0.7 172.18.0.6 172.18.0.5 root@liu:~/work/go/src/github.com/hyperledger/fabric/examples/e2e_cli# 版本控制 Version Action Time 1.0 Init 2019-04-25T04:26:27-07:00</description>
    </item>
    
    <item>
      <title>Go-Lession</title>
      <link>https://astr0mfly.github.io/blog/2019-04/go-lession/</link>
      <pubDate>Thu, 25 Apr 2019 04:21:58 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/go-lession/</guid>
      <description>启动两个线程，合并输出 package main import &amp;quot;fmt&amp;quot; func main() { ch1 := make(chan int) ch2 := make(chan int) go func() { for i := 0; i &amp;lt; 10; i++ { if i%2 == 0 { ch1 &amp;lt;- i } } }() go func() { for i := 0; i &amp;lt; 10; i++ { if i%2 == 1 { ch2 &amp;lt;- i } } }() tmp := 0 for i := 0; i &amp;lt; 5; i++ { tmp = &amp;lt;-ch1 fmt.Println(tmp) tmp = &amp;lt;-ch2 fmt.Println(tmp) } } for-range package main import &amp;quot;fmt&amp;quot; func main() { slice := []int{0, 1, 2, 3} mp := make(map[int]*int) fmt.Println(&amp;quot;for range 坑&amp;quot;) for index, value := range slice { mp[index] = &amp;amp;value } //根本原因在于for range是用一个变量承接mp中的内容的 for key, value := range mp { fmt.Println(key, &amp;quot; &amp;quot;, *value) } fmt.Println(&amp;quot;等价写法&amp;qu</description>
    </item>
    
    <item>
      <title>distributed-mapreduce</title>
      <link>https://astr0mfly.github.io/blog/2019-04/distributed-mapreduce/</link>
      <pubDate>Thu, 25 Apr 2019 03:51:49 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/distributed-mapreduce/</guid>
      <description>MapReduce(并行运算编程模型)基础概念 MapReduce是一种编程模型，用于大规模数据集（大于1TB）的并行运算。概念&amp;rdquo;Map（映射）&amp;rdquo;和&amp;rdquo;Reduce（归约）&amp;rdquo;，是它们的主要思想.软件实现是指定一个Map（映射）函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归约）函数，用来保证所有映射的键值对中的每一个共享相同的键组。</description>
    </item>
    
    <item>
      <title>C&#43;&#43;如何做到反射</title>
      <link>https://astr0mfly.github.io/blog/2019-04/c-%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Thu, 25 Apr 2019 03:10:41 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/c-%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%8F%8D%E5%B0%84/</guid>
      <description>什么是反射 反射机制在java中是一个非常重要的特性，比如在spring框架中，就使用了xml + 反射来完成类的动态扩展。 换句话说，反射就是根据一个字符串查找到一个类，查找到一个函数，并能生成这个类，或者函数的实例；就是在运行期通过字符串到内存单元的反向映射。 怎么做到反射 在动态语言中，反射是非常容易实现的，在java中，由于有字节码作为中间层的存在，所以实现也并不复杂。但是对于c++来说，静态编译的程</description>
    </item>
    
    <item>
      <title>git-flow</title>
      <link>https://astr0mfly.github.io/blog/2019-04/git-flow/</link>
      <pubDate>Wed, 24 Apr 2019 20:24:45 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/git-flow/</guid>
      <description>Devops = &amp;ldquo;Development&amp;rdquo; + &amp;ldquo;Operations&amp;rdquo; DevOps 是一个完整的面向IT运维的工作流，以 IT 自动化以及持续集成（CI）、持续部署（CD）为基础，来优化程式开发、测试、系统运维等所有环节。 在敏捷开发的基础上，提出开发与运营之间的软件版本迭代循环。 工具链 代码管理（SCM）：GitHub、GitLab、BitBucket、SubVersion 构建工具：Ant、Gradle、maven 自动部署：Capistrano、CodeDeploy 持续集成（</description>
    </item>
    
    <item>
      <title>基于GO的分布式云存储框架</title>
      <link>https://astr0mfly.github.io/blog/2019-04/%E5%9F%BA%E4%BA%8Ego%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%91%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Wed, 24 Apr 2019 20:21:23 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/%E5%9F%BA%E4%BA%8Ego%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%91%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6/</guid>
      <description>AstroCloudFIle 基于golang实现的一种分布式云存储服务 关于分支和标签 分支说明: master分支: 通过原生net/http实现各接口功能 gin分支: 通过Gin框架来改造(微服务化章节之后主要基于Gin框架来进行演示) pkg分支: 通过go-bindata等工具实现静态资源打包的一个示例 标签 tag是分支代码某个阶段的快照。如master主分支的v0.1是首个发布的版本，该版本是接入了阿里OSS。 关于需要手动安装的</description>
    </item>
    
    <item>
      <title>设计模式</title>
      <link>https://astr0mfly.github.io/blog/2019-04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 24 Apr 2019 08:14:44 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>简介 推荐书籍《设计模式&amp;ndash;可复用面向对象软件的基础》 底层思维：向下，把握机器底层-&amp;gt;语言构造、编译转换、内存模型、运行机制 抽象思维：面向对象、组件封装、设计模式、架构模式 深入理解三大面向对象机制： - 封装，隐藏内部实现 - 继承，复用现有代码 - 多态，改写对象行为 设计模式详解 策略模式 起因 软件构造的过程中，算法和对象容易耦合，那么能不能让算法与对象本身解耦呢？ 要点 Strategy及其字类为组</description>
    </item>
    
    <item>
      <title>Go-国内下载官方工具</title>
      <link>https://astr0mfly.github.io/blog/2019-04/go-%E5%9B%BD%E5%86%85%E4%B8%8B%E8%BD%BD%E5%AE%98%E6%96%B9%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 24 Apr 2019 06:45:07 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/go-%E5%9B%BD%E5%86%85%E4%B8%8B%E8%BD%BD%E5%AE%98%E6%96%B9%E5%B7%A5%E5%85%B7/</guid>
      <description>国内下载golang.org中的工具包 国内有某种不可描述的原因，导致无法访问 golang.org,但是使用golang时官方工具包是必不可少的一部分. golang.org/x/这个目录，其实镜像托管在 github.com/golang/ GIT迁移 将Github的包下载到本地后，移动到相应的目录中. 如: net &amp;ndash;&amp;gt;&amp;gt; GOPATH/src/golang.org/x/net crypto &amp;ndash;&amp;gt;&amp;gt; GOPATH/src/golang.org/x/crypto build &amp;ndash;&amp;gt;&amp;gt; GOPATH/src/golang.org/x/build &amp;hellip; GIT下载 在 $GOPATH/src/golang.org/x/ 下通过git 进行 clone 如: ~/go/src/golang.org/x$ git clone http://github.com/golang/build 然后用git pull直接维护更新本地代码 版本控制 Version Action Time 1.0 Init 2019-04-24T06:45:07-07:00</description>
    </item>
    
    <item>
      <title>Golang安装环境搭建</title>
      <link>https://astr0mfly.github.io/blog/2019-04/golang%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Mon, 22 Apr 2019 04:12:48 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/golang%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>Go安装包下载 由于Go的官方网址国内不可达，推荐一个国内的镜像源： go语言中文网.Go安装包下载 编译安装 下载Linux版本：go1.12.4.linux-amd64.tar.gz #在下载文件夹下的Shell敲一下如下命令 sudo tar -C /usr/local -xzvf go1.12.4.linux-amd64.tar.gz #/etc/profile（全系统安装）或 $HOME/.profile 添加环境变量 export PATH=$PATH:/usr/local/go/bin 也有另一种方法添加环境变量： # vim /etc/profile.d/go.sh export PATH=$PATH:/usr/local/go/bin export GOPATH=$HOME/dev/go export GOBIN=$GOPATH/bin :wq! # source /etc/profile.d/go.sh 验证结果 创建一个hello.go的文件 package main import &amp;quot;fmt&amp;quot; func main() { fmt.Printf(&amp;quot;hello,</description>
    </item>
    
    <item>
      <title>使用hugo制作静态个人界面</title>
      <link>https://astr0mfly.github.io/blog/2019-04/%E4%BD%BF%E7%94%A8hugo%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%95%8C%E9%9D%A2/</link>
      <pubDate>Mon, 22 Apr 2019 04:09:23 -0700</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/2019-04/%E4%BD%BF%E7%94%A8hugo%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E7%95%8C%E9%9D%A2/</guid>
      <description>安装hugo 建议到如下链接下载对应文件，使用go get挺慢的。 https://github.com/gohugoio/hugo/releases 安装hugo 生成site并且 clone 对应皮肤的Git到theme文件夹下 调试 ：hugo server --theme=hyde --buildDrafts 打开 : http://localhost:1313 实时调试 生成部署： hugo --theme=hyde 上传到git ： git push -u origin master 实例皮肤：redlougue hugo链接： https://github.com/tmaiaroto/hugo-redlounge 路径解释 config.toml 站点全局的参数配置文件 archetypes Hugo的markdown文件中前置数据Front Matter定义的结构，默认使用的是default.md文件，可以自</description>
    </item>
    
    <item>
      <title>《弗洛伊德与荣格：从相识到决裂》</title>
      <link>https://astr0mfly.github.io/moment/ronggejuelie/</link>
      <pubDate>Tue, 30 Jan 2018 15:04:48 +0800</pubDate>
      
      <guid>https://astr0mfly.github.io/moment/ronggejuelie/</guid>
      <description>西方有人认为：“20世纪是精神分析的世纪。”这种说法虽然不免过于夸大，但却从某种角度说明了精神分析理论在西方所产生的影响之大。弗洛伊德作为这一理论的创建者，荣格作为这一理论的有力推动与发展者都成为现代心理学中极其重要的心理学家。而发生在这两位巨擎间的由相识到决裂的恩恩怨怨也就成为精神分析学史上的一个重大事件。 我们本文中所要做的就是重新回顾那段历史，去了解发生在两人间的一场恩怨沧桑。 一、相识 我们先从</description>
    </item>
    
    <item>
      <title>穷爸爸富爸爸读后感</title>
      <link>https://astr0mfly.github.io/moment/qiongbabafubaba/</link>
      <pubDate>Tue, 30 Jan 2018 15:04:48 +0800</pubDate>
      
      <guid>https://astr0mfly.github.io/moment/qiongbabafubaba/</guid>
      <description>章一 富爸爸 穷爸爸（观念的转变） 富人之所以越来越富，穷人之所以越来越穷，中产阶级之所以总是在债务泥潭中挣扎，其主要原因之一在于他们对金钱观念不是来自学校，而是来自家庭。 一个人的观念对其一生有着巨大影响力。 一个爸爸说“我可付不起” 另一个则禁止这类话。他说“我怎样才能付得起呢？”这两句话一个是陈述句，一个是疑问句；一个让你放弃，另一个则促使你想办法。富爸爸常说“脑袋越用越活，脑袋越活，挣钱就越多”，在他</description>
    </item>
    
    <item>
      <title></title>
      <link>https://astr0mfly.github.io/about/tech_serverline/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://astr0mfly.github.io/about/tech_serverline/</guid>
      <description>后端开发基本知识框架  .task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }   body { font-family: -apple-system, BlinkMacSystemFont, &#39;Segoe WPC&#39;, &#39;Segoe UI&#39;, &#39;Ubuntu&#39;, &#39;Droid Sans&#39;, sans-serif; font-size: 14px; line-height: 1.6; }      date: &amp;quot;2019-04-29T01:43:01-07:00&amp;quot; draft: true title: &amp;quot;Tech_ServerLine&amp;quot; tags: [] series: [] categories: [] toc: true 后端开发基本知识框架 编程语言 主力语言 C/C++ Golang 脚本语言 Shell  介绍  此类脚本语言的意义在于辅助后端开发，包括系统运维，工具集成（借助管道、重定向），文本处理，数据计算等工作，提升后端工作效率   核心知识点  常用的linux操作和运维命令 管道、重定向 awk、sed等文本处理工具   推荐书籍  《linux与unix shell编程指南》 《鸟哥的Linux私房菜》 《Python编程 从入门到实践》    SQL语言  介绍  通用于传统关系型数据库和大数据场景的结构化查询模型语言。传统数据库方面要精通mysql的sql语法；大数据场景主要掌握Hive SQL（Impala和Spark SQL等均在兼容Hive SQL）   核心知识点  区分DDL和DML 经典查询语句主要结构 表连接（内连接，左外连接，右外连接，全连接） 函数（普通函数，聚合函数） 索引 分区   适用场景  传统数据库，传统SQL：用于事务性数据操作，通常用于系统的业务库； 大数据场景下的SQL：用于数据分析，交互式查询，批量数据处理等。   推荐书籍  MySQL：《高性能MySQL》 Hive SQL：《Hive编程指南》    其他/拓展 开发工具 开发IDE Eclipse  核心知识点  配置良好代码风格模板，包括文件注释，类注释，方法注释，缩进换行等 安装使用必要的插件：代码规范检查插件(Alibaba Java Coding Guidelines)，源码潜在bug检查插件(pmd）,字节码潜在bug检查插件（findbugs）等    工程构建 Maven  核心知识点  版本管理 Git  介绍  git是一个开源的分布式版本控制系统，通过规范化的工具和流程，使得开发者之间高效协同，保持产品稳定运行   推荐文章  Git &amp;amp;&amp;amp; Git Flow 使用总结    开发/测试框架 SpringBoot框架体系 Orm框架 mybatis/hibernate 测试框架 Junit/TestNG  核心能力要求  熟练使用Junit/TestNG进行单元测试，接口测试 学会借助Mockito解决外部系统，模块依赖的mock测试 学会使用maven的surfire plugin和jacoco plugin等插件，度量测例的通过率，测试代码覆盖率等指标    数据库/中间件 key-value存储系统  典型：redis/memcache 核心知识点  redis配置策略（持久化策略，替换算法等） redis的部署模式（standalone单机,sentinel哨兵,cluster集群），哨兵的本质是主从切换，cluster是真正的分布式部署可以线性扩展内存资源 redis支持的数据结构   适用场景  分布式session存储，数据缓存，分布式锁，简单的消息队列，计数器（累加器）    消息队列  典型：rabbitmq/kafka 核心知识  rabbitMQ  AMQP协议对应消息模型中的主要概念 两种集群模式对比：普通集群和镜像集群(HA)   kafka  基于zk的分布式拓扑结构 理解kafka支持的消息的写入流程，写入模式，消息的存储模式，消息的消费方式等   使用场景  消息中间件一般适用于：系统之间需要高度解耦；异步传输数据（非阻塞）；保证数据传输过程中数据可以持久化，解决生产端和消费端能力不一致的问题，避免峰值数据对下游服务节点的冲击等 对比rabbitmq和kafka: rabbitmq主要适用数据可靠性，一致性要求比较高的场景；kafka主要适用数据吞吐量比较的场景，如日志数据的实时传输等      分布式文件存储  典型： 网易NOS/阿里云OSS 适用场景：  存储需要在分布式架构下共享的文件对象：如前端静态文件，图片资源，大文件资源    服务治理/RPC框架  典型：阿里dubbo 核心知识点  注册中心，服务注册、服务发现、负载均衡、序列化反序列化、编码解码等核心概念 适用场景  在相对复杂的应用服务网络中，扮演服务治理、服务解耦、负载均衡、简化服务调用方式的作用      Web容器 Nginx  介绍  本质上是HTTP和反向代理服务器   适用场景  Http服务器，反响代理，软负载均衡器等    关系型数据库  典型：mySQL 核心知识点  索引 事务与事务隔离级别 存储方法 触发器 不同关系型数据库的SQL差异   推荐书籍  《高性能MySQL》    大数据存储和计算框架等  核心能力要求  了解大数据体系整体的框架、组成 熟悉各种大数据存储，计算框架，查询引擎等主要的架构、功能和适用场景 能够在项目的架构过程中进行合理的大数据技术方案选型    软件工程 权限相关 安全相关 日志相关 异常处理相关 RestFul接口设计相关 线上问题排查流程和工具 多线程编程 网络相关  核心知识点  掌握http协议消息体划分、连接和通信过程 掌握http主要的返回状态码意义 掌握https协议的连接和通信过程    设计模式  核心知识点  七大设计原则  单一职责 里氏替换 依赖倒置 接口隔离 迪米特 开闭 组合/聚合复用   常用设计模式  单例模式 策略模式 代理模式 观察者模式 装饰模式 适配器模式 组合模式 工厂模式 模板方法模式      分布式系统设计  核心知识点  分布式系统架构设计  SOA 微服务   分布式事务  一致性理论  CAP定理 BASE理论   一致性模型  强一致性 弱一致性 最终一致性   分布式事务解决方案  强一致性（两段提交和三段提交模型，paxos或者raft算法） 最终一致性  eBay 事件队列方案 TCC 补偿模式 缓存数据最终一致性     分布式锁  基于数据库 基于缓存 基于zookeeper   分布式定时器  Quartz, 基于数据库锁的抢占式分布式定时器        版本控制    Version Action Time     1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://astr0mfly.github.io/blog/1-01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://astr0mfly.github.io/blog/1-01/</guid>
      <description>series: []  .task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }   body { font-family: -apple-system, BlinkMacSystemFont, &#39;Segoe WPC&#39;, &#39;Segoe UI&#39;, &#39;Ubuntu&#39;, &#39;Droid Sans&#39;, sans-serif; font-size: 14px; line-height: 1.6; }      date: &amp;quot;2019-04-29T02:47:43-07:00&amp;quot; draft: false title: &amp;quot;Tcp-Reaction&amp;quot; tags: [cpp] #series: [] categories: [编码之道] toc: true TCP通信基本流程 Windows 和 Linux 上常用的 socket API 函数并不多，除了特定操作系统提供的一些基于自身系统特性的 API， 大多数 Socket API 都源于BSD Socket （即伯克利套接字（Berkeley Sockets）），因此这些 socket 函数在不同的平台有着相似的签名和参数。
 linux 查看socket函数帮助  man bind、man man、man 3 sleep   windows 查看帮助  使用在线版本的 MSDN    理论剖析  服务端流程    调用 socket 函数创建 socket（侦听socket） 调用 bind 函数 将 socket绑定到某个ip和端口的二元组上 调用 listen 函数 开启侦听 当有客户端请求连接上来后，调用 accept 函数接受连接，产生一个新的 socket（客户端 socket） 基于新产生的 socket 调用 send 或 recv 函数开始与客户端进行数据交流 通信结束后，调用 close 函数关闭侦听 socket    客户端流程    调用 socket函数创建客户端 socket 调用 connect 函数尝试连接服务器 连接成功以后调用 send 或 recv 函数开始与服务器进行数据交流 通信结束后，调用 close 函数关闭侦听socket   上述流程交互总结如下： 代码实现 Server
#include &amp;lt;sys/types.h&amp;gt;  #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;arpa/inet.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;string.h&amp;gt; int main(int argc, char* argv[]) { //1.创建一个侦听socket int listenfd = socket(AF_INET, SOCK_STREAM, 0); if (listenfd == -1) { std::cout &amp;lt;&amp;lt; &#34;create listen socket error.&#34; &amp;lt;&amp;lt; std::endl; return -1; } //2.初始化服务器地址 struct sockaddr_in bindaddr; bindaddr.</description>
    </item>
    
  </channel>
</rss>